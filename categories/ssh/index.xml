<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ssh on datDhruv's Blog</title><link>https://datdhruv.github.io/categories/ssh/</link><description>Recent content in ssh on datDhruv's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 02 Oct 2023 18:30:00 +0400</lastBuildDate><atom:link href="https://datdhruv.github.io/categories/ssh/index.xml" rel="self" type="application/rss+xml"/><item><title>Why SSH port Forwarding gives you superpowers</title><link>https://datdhruv.github.io/p/why-ssh-port-forwarding-gives-you-superpowers/</link><pubDate>Wed, 19 May 2021 12:00:00 +0400</pubDate><guid>https://datdhruv.github.io/p/why-ssh-port-forwarding-gives-you-superpowers/</guid><description>&lt;h2 id="what-is-port-forwarding">&lt;strong>What is Port Forwarding?&lt;/strong>&lt;/h2>
&lt;p>Port Forwarding allows you to make a port on a computer behave like it is part of some other computer.&lt;/p>
&lt;p>Say you are running a website on a computer A, on &lt;code>localhost:8080&lt;/code>, you can forward this port to another computer B and then any connection to &lt;code>computer-B:8080&lt;/code> will be &lt;strong>tunneled&lt;/strong> back to computer A.&lt;/p>
&lt;p>This was an example of local port forwarding.&lt;/p>
&lt;p>You can go the other way round as well, having a website run on &lt;code>computer-B:8080&lt;/code> and tunnel it to the Computer A. This is called remote port forwarding.&lt;/p>
&lt;h2 id="a-little-more-explanation">A little more Explanation&lt;/h2>
&lt;p>Let us consider the &amp;ldquo;tunnel&amp;rdquo;.&lt;/p>
&lt;p>The tunnel has a start and an end and the traffic is tunneled from start to end.&lt;/p>
&lt;p>When the tunnel ends at our local Machine host, it&amp;rsquo;s called a local port forward (Tunnel ends at Local port) whereas when the tunnel starts at local port &amp;amp; ends at the remote port it&amp;rsquo;s called remote port forwarding&lt;/p>
&lt;hr>
&lt;p>The first IP is for specifying access.&lt;/p>
&lt;p>Who has access? &lt;code>localhost&lt;/code> or anyone on the network?&lt;/p>
&lt;p>While in local port forwarding, you can have a setup wherein only you, on your own machine can access this website. There can be another arrangement wherein you can allow others on your network to access the tunnel/local port forward. In this situation they will access it via &lt;code>yourip:forward-binded-port&lt;/code>&lt;/p>
&lt;p>Same for remote. If an ip is specified then only access to remote tunnel. No other ip on the network can access this IP address.&lt;/p>
&lt;hr>
&lt;p>When you use the -L flag, you can &lt;strong>bind&lt;/strong> the remote port to the local port and listen to incoming connections on that port&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">-L &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port:host:hostport
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-L &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port:remote_socket
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-L local_socket:host:hostport
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-L local_socket:remote_socket
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Specifies that connections to the given TCP port or Unix socket on the local (client) host are to be forwarded to the given host and port, or Unix socket, on the remote side. &lt;strong>This works by allocating a socket to listen to either a TCP port on the local side, optionally bound to the specified bind_address, or to a Unix socket.&lt;/strong> Whenever a connection is made to the local port or socket, the connection is forwarded over the secure channel, and a connection is made to either host port hostport, or the Unix socket remote_socket, from the remote machine.&lt;/p>
&lt;p>Port forwardings can also be specified in the configuration file. Only the superuser can forward privileged ports. IPv6 addresses can be specified by enclosing the address in square brackets.&lt;/p>
&lt;p>By default, the local port is bound in accordance with the GatewayPorts setting. However, an explicit bind_address may be used to bind the connection to a specific address. The bind_address of &lt;code>localhost&lt;/code> indicates that the listening port be bound for local use only, while an empty address or &lt;code>*&lt;/code> indicates that the port should be available from all interfaces.&lt;/p>
&lt;p>If remote port forwarding does not work, it is most likely because GatewayPorts is set to no in the sshd_config file.&lt;/p>
&lt;p>Remember, in local port forwarding, A request to my computer&amp;rsquo;s port is &lt;em>forwarded&lt;/em> to a remote computer&amp;rsquo;s port and in remote port forwarding, requests to a remote computer&amp;rsquo;s port are &lt;em>forwarded&lt;/em> to my computer&amp;rsquo;s port.&lt;/p>
&lt;p>This means that the meaning of host varies depending upon if the the port forwarding is local or remote. In local port forwarding, the host is the ssh-server. Whereas in remote port forwarding the host is the ssh-client (host is the one which &lt;em>hosts something on a port&lt;/em>)&lt;/p>
&lt;p>&lt;strong>NOTE&lt;/strong>: Sometimes you need to explicitly mention 127.0.0.1/localhost (I have experienced this on windows).&lt;/p>
&lt;hr>
&lt;h3 id="the-vpn-functionality">The VPN functionality&lt;/h3>
&lt;p>&lt;strong>This superpower can be used to tunnel connections to various sites that are not accessible to your local computer!!&lt;/strong> These might be databases or protected webservers.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># The folloiwing tunnel/forward any network traffic origination from your local computer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># to the super secret website&amp;#39;s port 5432&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ssh -L 127.0.0.1:5000:someSuperSecretSecretWebsite.com:5432 user@machine
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>You can further forward ports through jump servers.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">ssh -L local_socket:host:hostport user@machine1 ssh -L local_socket:host:hostport user@machine2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="forwarding-with-an-already-established-ssh-connection">Forwarding with an already established ssh connection&lt;/h2>
&lt;p>Note: &lt;code>~&lt;/code> is the escape sequence for ssh by default. If it doesnt work immediately, you may need to press enter once and the try entering &lt;code>~&lt;/code>&lt;/p>
&lt;p>&lt;code>~ C&lt;/code> Brings up a (local) ssh shell, wherein you can then ask for port forwarding the same way we did earlier.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">-L &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port:host:hostport
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-R &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port:host:hostport
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="further-you-can-stop-the-port-forwarding">Further you can stop the port forwarding&lt;/h2>
&lt;p>Enter the ssh command mode, then input the forwarding command with a leading &lt;strong>K&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">-KL &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-KR &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Running oneoff process in the background over ssh</title><link>https://datdhruv.github.io/p/running-oneoff-process-in-the-background-over-ssh/</link><pubDate>Mon, 02 Oct 2023 18:30:00 +0400</pubDate><guid>https://datdhruv.github.io/p/running-oneoff-process-in-the-background-over-ssh/</guid><description>&lt;p>Imagine a situation where you need to download a large file from the internet to a remote server.&lt;/p>
&lt;p>You run &lt;code>curl https://download.com -o download&lt;/code> and logout of the ssh server. &lt;strong>Big mistake!&lt;/strong> you come back hours later just to see that the download ended as soon as you logged out.&lt;/p>
&lt;p>The &lt;code>nohup&lt;/code> command helps here. &lt;code>nohup&lt;/code> stands for no hold up, and will run the command without any external interruptions. you can further run the command in the background using &lt;code>&amp;amp;&lt;/code>.&lt;/p>
&lt;p>Here&amp;rsquo;s the example:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ nohup curl https://download.com -o download &lt;span class="p">&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Useful Shell Shortcuts</title><link>https://datdhruv.github.io/p/useful-shell-shortcuts/</link><pubDate>Wed, 26 Oct 2022 12:30:00 +0400</pubDate><guid>https://datdhruv.github.io/p/useful-shell-shortcuts/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Key Binding&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>ESC f&lt;/code>, &lt;code>ESC b&lt;/code>&lt;/td>
&lt;td>Go forward/backword one word&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>CTRL a&lt;/code>, &lt;code>CTRL e&lt;/code>&lt;/td>
&lt;td>Go to start/end of line&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>~ C&lt;/code>&lt;/td>
&lt;td>Enter SSH Command Mode&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>C-b&lt;/code>, &lt;code>C-f&lt;/code>&lt;/td>
&lt;td>Move backward/forward one character&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>M-b&lt;/code>, &lt;code>M-f&lt;/code>&lt;/td>
&lt;td>Move backward/forward by word&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>C-a&lt;/code>, &lt;code>C-e&lt;/code>&lt;/td>
&lt;td>Move to the beginning/end of the line&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>C-w&lt;/code>, &lt;code>M-d&lt;/code>&lt;/td>
&lt;td>Kill word backward/forward&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>C-d&lt;/code>, &lt;code>Backspace&lt;/code>&lt;/td>
&lt;td>Delete char forward/backward&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>C-d&lt;/code>&lt;/td>
&lt;td>may send EOF on an empty line&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>M-.&lt;/code>&lt;/td>
&lt;td>cycle through the argument to the previous commands&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>C-k&lt;/code>, &lt;code>C-u&lt;/code>&lt;/td>
&lt;td>Kill (to clipboard) to end of line/beginning of line&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>C-y&lt;/code>&lt;/td>
&lt;td>Yank from kill ring&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>M-y&lt;/code> (after &lt;code>C-y&lt;/code>)&lt;/td>
&lt;td>Cycle through kill ring history&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>C-t&lt;/code>, &lt;code>M-t&lt;/code>&lt;/td>
&lt;td>Transpose character/word&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>M-u&lt;/code>, &lt;code>M-l&lt;/code>, &lt;code>M-c&lt;/code>&lt;/td>
&lt;td>Upper, lower, or capitalize forward word&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>C-_&lt;/code>, &lt;code>C-x C-u&lt;/code>, &lt;code>C-/&lt;/code>&lt;/td>
&lt;td>Cycle through the undo list&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Note&lt;/em>: &lt;code>C&lt;/code> = &lt;code>Ctrl&lt;/code>, &lt;code>M&lt;/code> = Meta Key/modifier (&lt;code>alt&lt;/code> or &lt;code>esc&lt;/code>)&lt;/p></description></item><item><title>Copying Files Over a Remote Connection</title><link>https://datdhruv.github.io/p/copying-files-over-a-remote-connection/</link><pubDate>Fri, 09 Sep 2022 11:25:00 +0400</pubDate><guid>https://datdhruv.github.io/p/copying-files-over-a-remote-connection/</guid><description>&lt;h1 id="scp">SCP&lt;/h1>
&lt;p>SCP, or Secure Copy uses SSH to copy files or directories that you select.&lt;/p>
&lt;p>Since scp relies on ssh, it is available on the recent builds of windows (that pack ssh by default), mac and ofcourse linux.&lt;/p>
&lt;p>You can even copy files over jump or intermediate connections by specifiying the &lt;code>-o&lt;/code> flag, like this:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># To copy myfile.txt to /my/dir directory on your remote host&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">scp -o &lt;span class="s1">&amp;#39;ProxyJump your.jump.host&amp;#39;&lt;/span> myfile.txt remote.internal.host:/my/dir
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Note that with &lt;code>SSH version 9&lt;/code>, SCP now has a SFTP backend rather than the traditional rcp backend. More details can be found in the &lt;a class="link" href="https://www.openssh.com/txt/release-9.0" target="_blank" rel="noopener"
>release notes&lt;/a>&lt;/p>
&lt;h1 id="sftp">SFTP&lt;/h1>
&lt;p>sftp works like scp&lt;/p>
&lt;h1 id="rsync">RSYNC&lt;/h1>
&lt;p>On first use, Rsync copies all files and directories and then it copies only the files and directories that you have changed. It does not copy all the files and directories again.&lt;/p>
&lt;p>This command is not available on windows, so the not as cross platform as scp or sftp&lt;/p>
&lt;p>This is extremely useful when you want to copy folder which change often, and can be used as a remote backup solution&lt;/p></description></item><item><title>Laggy SSH-Server connections on Laptops</title><link>https://datdhruv.github.io/p/laggy-ssh-server-connections-on-laptops/</link><pubDate>Fri, 24 Dec 2021 20:12:56 +0400</pubDate><guid>https://datdhruv.github.io/p/laggy-ssh-server-connections-on-laptops/</guid><description>&lt;p>When using a laptop as a server, if the SSH connection is laggy, it may be because of a wireless card’s power-saving feature.&lt;/p>
&lt;p>You can turn this feature off by issuing the command&lt;/p>
&lt;p>&lt;code>iw &amp;lt;devname&amp;gt; set power_save off&lt;/code>&lt;/p>
&lt;p>You can view the status of iw using the command&lt;/p>
&lt;p>&lt;code>iw &amp;lt;devname&amp;gt; get power_save&lt;/code>&lt;/p>
&lt;p>and the device name &lt;code>&amp;lt;devname&amp;gt;&lt;/code> using the command &lt;code>ip a&lt;/code>&lt;/p>
&lt;p>iw is used to show / manipulate wireless devices and their configuration&lt;/p></description></item><item><title>Multihop SSH</title><link>https://datdhruv.github.io/p/multihop-ssh/</link><pubDate>Sun, 31 Oct 2021 12:00:00 +0400</pubDate><guid>https://datdhruv.github.io/p/multihop-ssh/</guid><description>&lt;p>OpenSSH v7.3 onward supports a &lt;code>-J&lt;/code> switch and a &lt;code>ProxyJump&lt;/code> option, which allow one or more comma-separated jump hosts, so, you can simply do this now:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ssh -J jumpuser1@jumphost1,jumpuser2@jumphost2,...,jumpuserN@jumphostN user@hostbe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>If you want to bind ports as well, You basically have three possibilities:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Tunnel from &lt;code>localhost&lt;/code> to &lt;code>host1&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ssh -L 9999:host2:1234 -N host1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>As noted above, the connection from &lt;code>host1&lt;/code> to &lt;code>host2&lt;/code> will not be secured.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Tunnel from &lt;code>localhost&lt;/code> to &lt;code>host1&lt;/code> and from &lt;code>host1&lt;/code> to &lt;code>host2&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ssh -L 9999:localhost:9999 host1 ssh -L 9999:localhost:1234 -N host2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>This will open a tunnel from &lt;code>localhost&lt;/code> to &lt;code>host1&lt;/code> and another tunnel from &lt;code>host1&lt;/code> to &lt;code>host2&lt;/code>. However the port &lt;code>9999&lt;/code> to &lt;code>host2:1234&lt;/code> can be used by anyone on &lt;code>host1&lt;/code>. This may or may not be a problem.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Tunnel from &lt;code>localhost&lt;/code> to &lt;code>host1&lt;/code> and from &lt;code>localhost&lt;/code> to &lt;code>host2&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ssh -L 9998:host2:22 -N host1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ssh -L 9999:localhost:1234 -N -p 9998 localhost
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>This will open a tunnel from &lt;code>localhost&lt;/code> to &lt;code>host1&lt;/code> through which the SSH service on &lt;code>host2&lt;/code> can be used. Then a second tunnel is opened from &lt;code>localhost&lt;/code> to &lt;code>host2&lt;/code> through the first tunnel.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Go with option 1. If the connection from &lt;code>host1&lt;/code> to &lt;code>host2&lt;/code> needs to be secured, go with option 2. Option 3 is mainly useful to access a service on &lt;code>host2&lt;/code> that is only reachable from &lt;code>host2&lt;/code> itself.&lt;/p></description></item><item><title>Installing kali linux on Raspberry pi when you have no monitor</title><link>https://datdhruv.github.io/p/installing-kali-linux-on-raspberry-pi-when-you-have-no-monitor/</link><pubDate>Wed, 25 Dec 2019 12:00:00 +0400</pubDate><guid>https://datdhruv.github.io/p/installing-kali-linux-on-raspberry-pi-when-you-have-no-monitor/</guid><description>&lt;h1 id="installing-kali-linux-on-raspberry-pi">Installing Kali linux on Raspberry Pi&lt;/h1>
&lt;ol>
&lt;li>Flash the image on to the sd card (I recommend using balena etcher)&lt;/li>
&lt;li>Before putting the SD card into the pi, in the boot folder, create a ssh file (just touch ssh in the boot folder)&lt;/li>
&lt;li>now come the more tricky part. connect the pi to the router (with a wire) and then ssh into it.&lt;/li>
&lt;li>use nmtui to to set up the network&lt;/li>
&lt;li>now you have to enable ssh at each subsequent boot. This is done using &lt;code>sudo systemctl enable ssh.service&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>And you are done! ✨🎉🎊🎆&lt;/p></description></item></channel></rss>