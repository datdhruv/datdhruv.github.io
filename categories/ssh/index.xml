<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ssh on datDhruv's Blog</title><link>https://datdhruv.github.io/categories/ssh/</link><description>Recent content in ssh on datDhruv's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 24 Dec 2021 20:12:56 +0400</lastBuildDate><atom:link href="https://datdhruv.github.io/categories/ssh/index.xml" rel="self" type="application/rss+xml"/><item><title>Why SSH port Forwarding gives you superpowers</title><link>https://datdhruv.github.io/p/why-ssh-port-forwarding-gives-you-superpowers/</link><pubDate>Wed, 19 May 2021 12:00:00 +0400</pubDate><guid>https://datdhruv.github.io/p/why-ssh-port-forwarding-gives-you-superpowers/</guid><description>&lt;h2 id="what-is-port-forwarding">&lt;strong>What is Port Forwarding?&lt;/strong>&lt;/h2>
&lt;p>Port Forwarding allows you to make a port on a computer behave like it is part of some other computer.&lt;/p>
&lt;p>Say you are running a website on a computer A, on &lt;code>localhost:8080&lt;/code>, you can forward this port to another computer B and then any connection to &lt;code>computer-B:8080&lt;/code> will be &lt;strong>tunneled&lt;/strong> back to computer A.&lt;/p>
&lt;p>This was an example of local port forwarding.&lt;/p>
&lt;p>You can go the other way round as well, having a website run on &lt;code>computer-B:8080&lt;/code> and tunnel it to the Computer A. This is called remote port forwarding.&lt;/p>
&lt;h2 id="a-little-more-explanation">A little more Explanation&lt;/h2>
&lt;p>Let us consider the &amp;ldquo;tunnel&amp;rdquo;.&lt;/p>
&lt;p>The tunnel has a start and an end and the traffic is tunneled from start to end.&lt;/p>
&lt;p>When the tunnel ends at our local Machine host, it&amp;rsquo;s called a local port forward (Tunnel ends at Local port) whereas when the tunnel starts at local port &amp;amp; ends at the remote port it&amp;rsquo;s called remote port forwarding&lt;/p>
&lt;hr>
&lt;p>The first IP is for specifying access.&lt;/p>
&lt;p>Who has access? &lt;code>localhost&lt;/code> or anyone on the network?&lt;/p>
&lt;p>While in local port forwarding, you can have a setup wherein only you, on your own machine can access this website. There can be another arrangement wherein you can allow others on your network to access the tunnel/local port forward. In this situation they will access it via &lt;code>yourip:forward-binded-port&lt;/code>&lt;/p>
&lt;p>Same for remote. If an ip is specified then only access to remote tunnel. No other ip on the network can access this IP address.&lt;/p>
&lt;hr>
&lt;p>When you use the -L flag, you can &lt;strong>bind&lt;/strong> the remote port to the local port and listen to incoming connections on that port&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">-L &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port:host:hostport
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-L &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port:remote_socket
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-L local_socket:host:hostport
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-L local_socket:remote_socket
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Specifies that connections to the given TCP port or Unix socket on the local (client) host are to be forwarded to the given host and port, or Unix socket, on the remote side. &lt;strong>This works by allocating a socket to listen to either a TCP port on the local side, optionally bound to the specified bind_address, or to a Unix socket.&lt;/strong> Whenever a connection is made to the local port or socket, the connection is forwarded over the secure channel, and a connection is made to either host port hostport, or the Unix socket remote_socket, from the remote machine.&lt;/p>
&lt;p>Port forwardings can also be specified in the configuration file. Only the superuser can forward privileged ports. IPv6 addresses can be specified by enclosing the address in square brackets.&lt;/p>
&lt;p>By default, the local port is bound in accordance with the GatewayPorts setting. However, an explicit bind_address may be used to bind the connection to a specific address. The bind_address of &lt;code>localhost&lt;/code> indicates that the listening port be bound for local use only, while an empty address or &lt;code>*&lt;/code> indicates that the port should be available from all interfaces.&lt;/p>
&lt;p>If remote port forwarding does not work, it is most likely because GatewayPorts is set to no in the sshd_config file.&lt;/p>
&lt;p>Remember, in local port forwarding, A request to my computer&amp;rsquo;s port is &lt;em>forwarded&lt;/em> to a remote computer&amp;rsquo;s port and in remote port forwarding, requests to a remote computer&amp;rsquo;s port are &lt;em>forwarded&lt;/em> to my computer&amp;rsquo;s port.&lt;/p>
&lt;p>This means that the meaning of host varies depending upon if the the port forwarding is local or remote. In local port forwarding, the host is the ssh-server. Whereas in remote port forwarding the host is the ssh-client (host is the one which &lt;em>hosts something on a port&lt;/em>)&lt;/p>
&lt;hr>
&lt;p>You can further forward ports through jump servers.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">ssh -L local_socket:host:hostport user@machine1 ssh -L local_socket:host:hostport user@machine2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="forwarding-with-an-already-established-ssh-connection">Forwarding with an already established ssh connection&lt;/h2>
&lt;p>Note: &lt;code>~&lt;/code> is the escape sequence for ssh by default. If it doesnt work immediately, you may need to press enter once and the try entering &lt;code>~&lt;/code>&lt;/p>
&lt;p>&lt;code>~ C&lt;/code> Brings up a (local) ssh shell, wherein you can then ask for port forwarding the same way we did earlier.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">-L &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port:host:hostport
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-R &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port:host:hostport
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="further-you-can-stop-the-port-forwarding">Further you can stop the port forwarding&lt;/h2>
&lt;p>Enter the ssh command mode, then input the forwarding command with a leading &lt;strong>K&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">-KL &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-KR &lt;span class="o">[&lt;/span>bind_address:&lt;span class="o">]&lt;/span>port
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Laggy SSH-Server connections on Laptops</title><link>https://datdhruv.github.io/p/laggy-ssh-server-connections-on-laptops/</link><pubDate>Fri, 24 Dec 2021 20:12:56 +0400</pubDate><guid>https://datdhruv.github.io/p/laggy-ssh-server-connections-on-laptops/</guid><description>&lt;p>When using a laptop as a server, if the SSH connection is laggy, it may be because of a wireless cardâ€™s power-saving feature.&lt;/p>
&lt;p>You can turn this feature off by issuing the command&lt;/p>
&lt;p>&lt;code>iw &amp;lt;devname&amp;gt; set power_save off&lt;/code>&lt;/p>
&lt;p>You can view the status of iw using the command&lt;/p>
&lt;p>&lt;code>iw &amp;lt;devname&amp;gt; get power_save&lt;/code>&lt;/p>
&lt;p>and the device name &lt;code>&amp;lt;devname&amp;gt;&lt;/code> using the command &lt;code>ip a&lt;/code>&lt;/p>
&lt;p>iw is used to show / manipulate wireless devices and their configuration&lt;/p></description></item><item><title>Multihop SSH</title><link>https://datdhruv.github.io/p/multihop-ssh/</link><pubDate>Sun, 31 Oct 2021 12:00:00 +0400</pubDate><guid>https://datdhruv.github.io/p/multihop-ssh/</guid><description>&lt;p>OpenSSH v7.3 onward supports aÂ &lt;code>-J&lt;/code>Â switch and aÂ &lt;code>ProxyJump&lt;/code>Â option, which allow one or more comma-separated jump hosts, so, you can simply do this now:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ssh -J jumpuser1@jumphost1,jumpuser2@jumphost2,...,jumpuserN@jumphostN user@hostbe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;p>If you want to bind ports as well, You basically have three possibilities:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Tunnel fromÂ &lt;code>localhost&lt;/code>Â toÂ &lt;code>host1&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ssh -L 9999:host2:1234 -N host1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>As noted above, the connection fromÂ &lt;code>host1&lt;/code>Â toÂ &lt;code>host2&lt;/code>Â will not be secured.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Tunnel fromÂ &lt;code>localhost&lt;/code>Â toÂ &lt;code>host1&lt;/code>Â and fromÂ &lt;code>host1&lt;/code>Â toÂ &lt;code>host2&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ssh -L 9999:localhost:9999 host1 ssh -L 9999:localhost:1234 -N host2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>This will open a tunnel fromÂ &lt;code>localhost&lt;/code>Â toÂ &lt;code>host1&lt;/code>Â and another tunnel fromÂ &lt;code>host1&lt;/code>Â toÂ &lt;code>host2&lt;/code>. However the portÂ &lt;code>9999&lt;/code>Â toÂ &lt;code>host2:1234&lt;/code>Â can be used by anyone onÂ &lt;code>host1&lt;/code>. This may or may not be a problem.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Tunnel fromÂ &lt;code>localhost&lt;/code>Â toÂ &lt;code>host1&lt;/code>Â and fromÂ &lt;code>localhost&lt;/code>Â toÂ &lt;code>host2&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ssh -L 9998:host2:22 -N host1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ssh -L 9999:localhost:1234 -N -p 9998 localhost
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>This will open a tunnel fromÂ &lt;code>localhost&lt;/code>Â toÂ &lt;code>host1&lt;/code>Â through which the SSH service onÂ &lt;code>host2&lt;/code>Â can be used. Then a second tunnel is opened fromÂ &lt;code>localhost&lt;/code>Â toÂ &lt;code>host2&lt;/code>Â through the first tunnel.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Go with option 1. If the connection fromÂ &lt;code>host1&lt;/code>Â toÂ &lt;code>host2&lt;/code>Â needs to be secured, go with option 2. Option 3 is mainly useful to access a service onÂ &lt;code>host2&lt;/code>Â that is only reachable fromÂ &lt;code>host2&lt;/code>Â itself.&lt;/p></description></item><item><title>Installing kali linux on Raspberry pi when you have no monitor</title><link>https://datdhruv.github.io/p/installing-kali-linux-on-raspberry-pi-when-you-have-no-monitor/</link><pubDate>Wed, 25 Dec 2019 12:00:00 +0400</pubDate><guid>https://datdhruv.github.io/p/installing-kali-linux-on-raspberry-pi-when-you-have-no-monitor/</guid><description>&lt;h1 id="installing-kali-linux-on-raspberry-pi">Installing Kali linux on Raspberry Pi&lt;/h1>
&lt;ol>
&lt;li>Flash the image on to the sd card (I recommend using balena etcher)&lt;/li>
&lt;li>Before putting the SD card into the pi, in the boot folder, create a ssh file (just touch ssh in the boot folder)&lt;/li>
&lt;li>now come the more tricky part. connect the pi to the router (with a wire) and then ssh into it.&lt;/li>
&lt;li>use nmtui to to set up the network&lt;/li>
&lt;li>now you have to enable ssh at each subsequent boot. This is done using &lt;code>sudo systemctl enable ssh.service&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>And you are done! âœ¨ðŸŽ‰ðŸŽŠðŸŽ†&lt;/p></description></item></channel></rss>